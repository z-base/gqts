<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Globally Qualified Trust Service (GQTS) Core</title>
    <script
      src="https://www.w3.org/Tools/respec/respec-w3c"
      class="remove"
      defer="defer"
    ></script>
    <script class="remove">
      var respecConfig = {
        specStatus: 'unofficial',
        shortName: 'gqts-core',
        github: 'z-base/gqts',
        group: 'none',
        editors: [
          { name: 'Jori Lehtinen', url: 'https://github.com/jortsupetterson' },
          {
            name: 'OpenAI GPT-5 Codex (LLM drafting assistant)',
            url: 'https://openai.com/',
          },
        ],
        lint: {
          'informative-dfn': true,
          'local-refs-exist': true,
          'no-unused-dfns': true,
        },
      }
    </script>
    <style>
      .mono {
        font-family: Consolas, Monaco, 'Courier New', monospace;
      }

      .tight td,
      .tight th {
        vertical-align: top;
      }

      .status-tag {
        display: inline-block;
        border: 1px solid #999;
        border-radius: 3px;
        padding: 0.1rem 0.35rem;
        font-size: 0.85em;
      }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document specifies <strong>GQTS Core</strong> as a protocol profile for publishing
        trust-service verification material under the GIDAS framework.
      </p>
      <p>
        GQTS Core defines discovery, append-only history invariants, divergence detection, merge
        semantics, and a deterministic verifier algorithm. Endpoint contracts are normative in
        <a href="./openapi.yaml">openapi.yaml</a> and rendered at
        <a href="./openapi/">./openapi/</a>.
      </p>
    </section>

    <section id="sotd">
      <p>This is an Editor's Draft.</p>
      <p>
        Document authority: this text is not an adopted ETSI deliverable, not a W3C Recommendation,
        and not a legal instrument. Normative force exists only where this draft is explicitly
        adopted by a governing standards process.
      </p>
      <p>
        Drafting note: automated editorial tooling was used. Normative intent and acceptance are
        controlled by human editors and explicit repository governance.
      </p>
    </section>

    <section id="conformance">
      <p>
        The key words <em class="rfc2119">MUST</em>, <em class="rfc2119">MUST NOT</em>,
        <em class="rfc2119">REQUIRED</em>, <em class="rfc2119">SHALL</em>,
        <em class="rfc2119">SHALL NOT</em>, <em class="rfc2119">SHOULD</em>,
        <em class="rfc2119">SHOULD NOT</em>, <em class="rfc2119">RECOMMENDED</em>,
        <em class="rfc2119">MAY</em>, and <em class="rfc2119">OPTIONAL</em> in this document
        are to be interpreted as described in BCP 14
        <a href="#ref-rfc2119">[RFC2119]</a>
        <a href="#ref-rfc8174">[RFC8174]</a> when, and only when, they appear in all capitals.
      </p>
      <p>
        Conforming implementations MUST satisfy all requirements for at least one conformance
        class in <a href="#conformance-classes">Conformance Classes</a>.
      </p>
      <p>
        This specification defines externally observable data models, protocol outcomes, and
        verifier algorithms. It does not define implementation architecture, runtime internals, or
        performance strategies.
      </p>
    </section>

    <section id="positioning-adoption-model" class="informative">
      <h2>Positioning and Adoption Model</h2>
      <p>
        This section states stakeholder adoption pathways as a mapping from objective to required
        artifacts and verifier-observable outcomes.
      </p>
      <table class="simple tight">
        <thead>
          <tr>
            <th>Stakeholder</th>
            <th>Goal</th>
            <th>Required Artifact/Interface</th>
            <th>Verifier Behavior</th>
            <th>Adoption Pathway</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Device and platform manufacturers</td>
            <td>Provide auditable key-custody and signer-intent evidence surfaces.</td>
            <td>Controller/key evidence objects and integrity proofs exposed through GQTS logs.</td>
            <td>Verify proof chains, key-state continuity, and event-history integrity.</td>
            <td>Publish conformance targets and expose machine-verifiable evidence interfaces.</td>
          </tr>
          <tr>
            <td>Wallet and application implementers</td>
            <td>Implement end-user controlled signing and attestation workflows.</td>
            <td>Event envelopes, proof objects, and service descriptors conforming to OpenAPI schemas.</td>
            <td>Validate deterministic event processing and proof verification outcomes.</td>
            <td>Ship profile-conformant interfaces and publish conformance evidence artifacts.</td>
          </tr>
          <tr>
            <td>Standards development organizations</td>
            <td>Define interoperable profiles and test suites.</td>
            <td>Profile constraints, test assertions, and registry/discovery policies.</td>
            <td>Execute profile test assertions against normative schemas and algorithms.</td>
            <td>Publish profile work items and normative deltas over GQTS Core.</td>
          </tr>
          <tr>
            <td>Governments and regulators</td>
            <td>Publish authoritative policy and recognition inputs.</td>
            <td>Authoritative registries, trusted lists, and governance discovery endpoints.</td>
            <td>Separate cryptographic validity outputs from legal recognition outputs.</td>
            <td>Adopt compatibility mappings without changing core cryptographic semantics.</td>
          </tr>
          <tr>
            <td>Auditors, CABs, and assessors</td>
            <td>Evaluate conformance using machine-verifiable evidence.</td>
            <td>Conformance reports, test transcripts, and evidence artifacts bound to requirement IDs.</td>
            <td>Check requirement-level traceability and deterministic failure handling.</td>
            <td>Issue assessment outputs bound to reproducible verification procedures.</td>
          </tr>
          <tr>
            <td>Verifiers and relying parties</td>
            <td>Make deterministic acceptance decisions from evidence.</td>
            <td>Scheme/type/event retrieval endpoints and policy input registries.</td>
            <td>Execute verifier algorithm and reject unverifiable or inconsistent states.</td>
            <td>Integrate GQTS retrieval and verification as a policy-separated trust layer.</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section id="framework-naming">
      <h2>Framework Naming</h2>
      <ul>
        <li>
          <strong>GIDAS</strong> (Global Identity, Authentication, and Trust Services) is the
          framework umbrella.
        </li>
        <li>
          <strong>GDIS</strong> (Global Digital Identity Scheme) is a component under GIDAS for
          physical-to-digital identity binding artifacts.
        </li>
        <li>
          <strong>GQSCD</strong> (Globally Qualified Signature Creation Device) is a component
          under GIDAS for device/controller assurance evidence.
        </li>
        <li>
          <strong>GQTS Core</strong> (this specification) is the shared publication and
          replication substrate for verifier-checkable trust-service evidence.
        </li>
      </ul>
    </section>

    <section id="scope">
      <h2>Scope</h2>
      <p>This specification defines:</p>
      <ul>
        <li>a `/.well-known/` discovery profile for GQTS resources;</li>
        <li>append-only event history invariants and merge rules;</li>
        <li>open-participation replication with opportunistic synchronization;</li>
        <li>
          a mechanical verifier algorithm that separates cryptographic validity from recognition
          or legal status decisions.
        </li>
      </ul>
      <p>This specification does not:</p>
      <ul>
        <li>create legal qualification by itself;</li>
        <li>replace jurisdictional trusted lists or statutory registries;</li>
        <li>mandate one storage engine, one host operator, or one governance authority.</li>
      </ul>
    </section>

    <section id="terminology">
      <h2>Terminology</h2>
      <dl>
        <dt><dfn>GQTS host</dfn></dt>
        <dd>
          An HTTP origin that serves GQTS resources and MAY ingest, replicate, and gossip
          append-only event history material.
        </dd>

        <dt><dfn>service descriptor</dfn></dt>
        <dd>
          A machine-readable object describing one trust-service instance, its type, and its
          current event-log head commitment.
        </dd>

        <dt><dfn>scheme descriptor</dfn></dt>
        <dd>
          A machine-readable governance-scoped object describing naming rules, proof profile,
          canonicalization profile, and publication floor requirements.
        </dd>

        <dt><dfn>event namespace</dfn></dt>
        <dd>
          A scoped event stream identified by a log identifier where entries form an append-only
          history.
        </dd>

        <dt><dfn>head digest</dfn></dt>
        <dd>
          Commitment to the latest accepted history head for an <a>event namespace</a>, used for
          cheap divergence detection before heavy synchronization.
        </dd>

        <dt><dfn>merge event</dfn></dt>
        <dd>
          An event entry that references two or more parent heads to represent explicit history
          convergence.
        </dd>

        <dt><dfn>mechanical validity</dfn></dt>
        <dd>
          A verifier result stating that schema constraints, signatures/proofs, canonicalization,
          and hash-chain requirements were satisfied.
        </dd>

        <dt><dfn>recognition status</dfn></dt>
        <dd>
          A policy output derived from external governance sources (for example trusted lists,
          legal registries, contractual trust anchors), separate from <a>mechanical validity</a>.
        </dd>

        <dt><dfn>governance code</dfn></dt>
        <dd>
          A normalized identifier for governance-scoped objects. In this profile, values MUST be
          lowercase ASCII and match the pattern defined by the OpenAPI schema
          <a href="#schema-GovernanceCode">`GovernanceCode`</a>.
        </dd>
      </dl>
    </section>

    <section id="openapi-surface">
      <h2>Normative Interface Surface</h2>
      <p>
        <span class="status-tag">Normative Endpoint Contract</span>
      </p>
      <p>
        Endpoint semantics are normative in <a href="./openapi.yaml">`./openapi.yaml`</a>
        (OpenAPI 3.1.2). Rendered documentation is available at
        <a href="./openapi/">`./openapi/`</a>.
      </p>
      <p>
        This ReSpec document MUST NOT restate endpoint wire contracts. It defines invariant
        constraints, threat-model boundaries, and verifier processing semantics that apply to
        OpenAPI-delivered objects.
      </p>

      <section id="openapi-operation-anchors">
        <h3>Operation Anchors</h3>
        <table class="simple tight">
          <thead>
            <tr>
              <th>OperationId</th>
              <th>Purpose</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                <a id="op-getSchemeDescriptor" href="./openapi/#operation/getSchemeDescriptor"
                  ><code>getSchemeDescriptor</code></a
                >
              </td>
              <td>Fetch governance-scoped scheme metadata.</td>
            </tr>
            <tr>
              <td>
                <a id="op-getEndpointKindCatalog" href="./openapi/#operation/getEndpointKindCatalog"
                  ><code>getEndpointKindCatalog</code></a
                >
              </td>
              <td>Fetch normative endpoint-kind taxonomy for a governance profile.</td>
            </tr>
            <tr>
              <td>
                <a id="op-getTypeDescriptor" href="./openapi/#operation/getTypeDescriptor"
                  ><code>getTypeDescriptor</code></a
                >
              </td>
              <td>Fetch one trust-service descriptor with current head commitment.</td>
            </tr>
            <tr>
              <td>
                <a id="op-getEventLogView" href="./openapi/#operation/getEventLogView"
                  ><code>getEventLogView</code></a
                >
              </td>
              <td>Fetch event-log head view or event page for a namespace.</td>
            </tr>
            <tr>
              <td>
                <a id="op-postEventIngest" href="./openapi/#operation/postEventIngest"
                  ><code>postEventIngest</code></a
                >
              </td>
              <td>Submit an ingest event; acceptance and state-transition semantics are normative in OpenAPI.</td>
            </tr>
            <tr>
              <td>
                <a id="op-getEventHeadMeta" href="./openapi/#operation/getEventHeadMeta"
                  ><code>getEventHeadMeta</code></a
                >
              </td>
              <td>Fetch compact event-head metadata for low-cost divergence checks.</td>
            </tr>
            <tr>
              <td>
                <a id="op-getEventById" href="./openapi/#operation/getEventById"
                  ><code>getEventById</code></a
                >
              </td>
              <td>Fetch one immutable event object by identifier.</td>
            </tr>
          </tbody>
        </table>
      </section>

      <section id="openapi-schema-anchors">
        <h3>Schema Anchors</h3>
        <ul>
          <li>
            <a
              id="schema-EndpointKind"
              href="./openapi.yaml#/components/schemas/EndpointKind"
              ><code>EndpointKind</code></a
            >
          </li>
          <li>
            <a
              id="schema-EndpointKindCatalog"
              href="./openapi.yaml#/components/schemas/EndpointKindCatalog"
              ><code>EndpointKindCatalog</code></a
            >
          </li>
          <li>
            <a
              id="schema-EndpointKindEntry"
              href="./openapi.yaml#/components/schemas/EndpointKindEntry"
              ><code>EndpointKindEntry</code></a
            >
          </li>
          <li>
            <a
              id="schema-GovernanceCode"
              href="./openapi.yaml#/components/schemas/GovernanceCode"
              ><code>GovernanceCode</code></a
            >
          </li>
          <li>
            <a
              id="schema-SchemeDescriptor"
              href="./openapi.yaml#/components/schemas/SchemeDescriptor"
              ><code>SchemeDescriptor</code></a
            >
          </li>
          <li>
            <a
              id="schema-ServiceDescriptor"
              href="./openapi.yaml#/components/schemas/ServiceDescriptor"
              ><code>ServiceDescriptor</code></a
            >
          </li>
          <li>
            <a
              id="schema-EventLogView"
              href="./openapi.yaml#/components/schemas/EventLogView"
              ><code>EventLogView</code></a
            >
          </li>
          <li>
            <a
              id="schema-EventHeadMeta"
              href="./openapi.yaml#/components/schemas/EventHeadMeta"
              ><code>EventHeadMeta</code></a
            >
          </li>
          <li>
            <a
              id="schema-EventEnvelope"
              href="./openapi.yaml#/components/schemas/EventEnvelope"
              ><code>EventEnvelope</code></a
            >
          </li>
          <li>
            <a
              id="schema-ErrorCode"
              href="./openapi.yaml#/components/schemas/ErrorCode"
              ><code>ErrorCode</code></a
            >
          </li>
          <li>
            <a
              id="schema-AsyncReceipt"
              href="./openapi.yaml#/components/schemas/AsyncReceipt"
              ><code>AsyncReceipt</code></a
            >
          </li>
        </ul>
      </section>

      <section id="media-type-governance">
        <h3>Media Type Governance</h3>
        <p>
          Media types in this profile follow RFC 6838
          <a href="#ref-rfc6838">[RFC6838]</a> and use the structured syntax suffix
          <code>+json</code> where semantics are JSON. Profile revisions MUST preserve backward
          compatibility expectations or publish a versioned media-type change policy.
        </p>
      </section>

      <section id="endpoint-kind-taxonomy">
        <h3>Endpoint-Kind Taxonomy (Normative)</h3>
        <table class="simple tight">
          <thead>
            <tr>
              <th>Endpoint Kind</th>
              <th>Primary Operation Anchors</th>
              <th>Primary Schema Anchors</th>
              <th>Consistency Model</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>scheme</code></td>
              <td>
                <a href="#op-getSchemeDescriptor"><code>getSchemeDescriptor</code></a>,
                <a href="#op-getEndpointKindCatalog"><code>getEndpointKindCatalog</code></a>
              </td>
              <td>
                <a href="#schema-SchemeDescriptor"><code>SchemeDescriptor</code></a>,
                <a href="#schema-EndpointKindCatalog"><code>EndpointKindCatalog</code></a>
              </td>
              <td>Mutable with explicit versioning and validators.</td>
            </tr>
            <tr>
              <td><code>type</code></td>
              <td>
                <a href="#op-getTypeDescriptor"><code>getTypeDescriptor</code></a>
              </td>
              <td>
                <a href="#schema-ServiceDescriptor"><code>ServiceDescriptor</code></a>
              </td>
              <td>Mutable with explicit head commitment references.</td>
            </tr>
            <tr>
              <td><code>event</code></td>
              <td>
                <a href="#op-getEventHeadMeta"><code>getEventHeadMeta</code></a>,
                <a href="#op-getEventLogView"><code>getEventLogView</code></a>,
                <a href="#op-postEventIngest"><code>postEventIngest</code></a>,
                <a href="#op-getEventById"><code>getEventById</code></a>
              </td>
              <td>
                <a href="#schema-EventHeadMeta"><code>EventHeadMeta</code></a>,
                <a href="#schema-EventLogView"><code>EventLogView</code></a>,
                <a href="#schema-EventEnvelope"><code>EventEnvelope</code></a>,
                <a href="#schema-AsyncReceipt"><code>AsyncReceipt</code></a>
              </td>
              <td>Append-only history with explicit merge events.</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>

    <section id="requirement-traceability">
      <h2>Requirement Traceability</h2>
      <p>
        Each normative requirement in this document is mapped to OpenAPI operation and schema
        anchors. Protocol invariants are defined here; wire contracts remain authoritative in
        OpenAPI. Each mapped operation carries the matching `x-gqts-requirement` extension in
        `openapi.yaml`.
      </p>
      <ol>
        <li id="req-gqts-01">
          <strong>REQ-GQTS-01 Discovery Scope</strong>:
          Implementations MUST support governance-scoped discovery via
          <a href="#op-getSchemeDescriptor"><code>getSchemeDescriptor</code></a>
          and schema constraints in
          <a href="#schema-SchemeDescriptor"><code>SchemeDescriptor</code></a>.
        </li>
        <li id="req-gqts-02">
          <strong>REQ-GQTS-02 Endpoint-Kind Publication</strong>:
          Implementations MUST publish endpoint-kind mapping material via
          <a href="#op-getEndpointKindCatalog"><code>getEndpointKindCatalog</code></a>
          conforming to
          <a href="#schema-EndpointKindCatalog"><code>EndpointKindCatalog</code></a>.
        </li>
        <li id="req-gqts-03">
          <strong>REQ-GQTS-03 Service Descriptor Integrity</strong>:
          Implementations MUST expose current service head commitments through
          <a href="#op-getTypeDescriptor"><code>getTypeDescriptor</code></a> using
          <a href="#schema-ServiceDescriptor"><code>ServiceDescriptor</code></a>.
        </li>
        <li id="req-gqts-04">
          <strong>REQ-GQTS-04 Low-Cost Divergence Detection</strong>:
          Verifiers and peers SHOULD compare compact head commitments via
          <a href="#op-getEventHeadMeta"><code>getEventHeadMeta</code></a> before heavy sync work.
        </li>
        <li id="req-gqts-05">
          <strong>REQ-GQTS-05 Append-Only Retrieval</strong>:
          Event history retrieval MUST use
          <a href="#op-getEventLogView"><code>getEventLogView</code></a> and
          <a href="#schema-EventLogView"><code>EventLogView</code></a>, preserving append-only
          interpretation rules.
        </li>
        <li id="req-gqts-06">
          <strong>REQ-GQTS-06 Asynchronous Ingest</strong>:
          Event ingest/gossip MUST be modeled as asynchronous acceptance through
          <a href="#op-postEventIngest"><code>postEventIngest</code></a> and corresponding
          ingestion-receipt objects represented by
          <a href="#schema-AsyncReceipt"><code>AsyncReceipt</code></a>.
        </li>
        <li id="req-gqts-07">
          <strong>REQ-GQTS-07 Immutable Event Addressing</strong>:
          Event-object retrieval MUST use
          <a href="#op-getEventById"><code>getEventById</code></a> and validate
          <a href="#schema-EventEnvelope"><code>EventEnvelope</code></a>.
        </li>
      </ol>
    </section>

    <section id="mandate-law">
      <h2>Normative Source Constraints</h2>
      <p>
        <span class="status-tag">External Fact Layer</span>
      </p>
      <section id="mandate-law-standards">
        <h3>Mandate (law/standards)</h3>
        <p>
          Statements about legal effect are constrained to this section. GQTS Core does not
          define legal recognition; it defines technical evidence and verification behavior.
        </p>
      </section>

      <section id="mandate-rfc8615">
        <h3>Well-Known URI Governance</h3>
        <p>
          GQTS discovery uses `/.well-known/` semantics and therefore depends on RFC 8615 rules
          and the IANA Well-Known URI registry process
          <a href="#ref-rfc8615">[RFC8615]</a>
          <a href="#ref-iana-wku">[IANA-WKU]</a>.
        </p>
      </section>

      <section id="mandate-eidas-terminology">
        <h3>Qualification Terminology Discipline</h3>
        <p>
          Terms such as "qualified", "notified", "listed", or "recognized" MUST be backed by
          independently verifiable legal or regulatory sources in the target jurisdiction, such as
          EU eIDAS legal texts and trusted-list frameworks where applicable
          <a href="#ref-eidas-910">[EU-910/2014]</a>
          <a href="#ref-eidas-consolidated">[EU-910-CONS]</a>
          <a href="#ref-eu-2024-1183">[EU-2024/1183]</a>
          <a href="#ref-eu-trusted-lists">[EU-TRUSTED-LISTS]</a>.
        </p>
      </section>

      <section id="mandate-openapi">
        <h3>OpenAPI Contract Authority</h3>
        <p>
          Endpoint behavior is authoritative in OpenAPI 3.1.2
          <a href="#ref-openapi31">[OPENAPI-3.1.2]</a>. ReSpec prose in this document is
          interpretive for invariants and verifier processing only.
        </p>
      </section>
    </section>

    <section id="gqts-model">
      <h2>GQTS Core Model Constraints</h2>
      <section id="well-known-path">
        <h3>Well-Known Discovery Path</h3>
        <p>
          The default discovery namespace is:
          <span class="mono">/.well-known/gidas/gqts/&lt;kind&gt;/&lt;id&gt;</span>.
        </p>
        <p>
          `<kind>` is an enumerated token set: `type`, `event`, `scheme`. `<id>` is either a
          UUID-like service/log identifier or a governance-scoped identifier validated by
          <a href="#schema-GovernanceCode">`GovernanceCode`</a>.
        </p>
      </section>

      <section id="history-invariants">
        <h3>Tamper-Evident History Invariants</h3>
        <ul>
          <li>History MUST be append-only; corrections are new events.</li>
          <li>Divergence MUST be detectable through differing head commitments.</li>
          <li>
            Merge MUST be explicit: a merge is represented as a new event referencing parent heads.
          </li>
          <li>
            Verification MUST be mechanical: canonicalization, digest-linking, and proof checks are
            deterministic.
          </li>
          <li>
            Hosts MUST NOT trigger heavy merge work unless a head digest mismatch is detected.
          </li>
        </ul>
      </section>

      <section id="replication-open-participation">
        <h3>Open Participation Replication</h3>
        <p>
          Replication is open participation: any origin MAY host and gossip GQTS material.
          Governance profiles MAY define minimum publication targets, but MUST NOT define a
          maximum or exclusive host set by schema.
        </p>
      </section>

      <section id="caching-rules">
        <h3>Caching and Conditional Retrieval</h3>
        <p>
          Hosts SHOULD expose `ETag` values aligned with head commitments. Verifiers and peers
          SHOULD use conditional retrieval (`If-None-Match`) before transferring event pages
          <a href="#ref-rfc9110">[RFC9110]</a>. Immutable event retrieval and append-only log views
          MUST declare cache behavior explicitly in the OpenAPI contract.
        </p>
      </section>

      <section id="threat-model-honesty">
        <h3>Threat Model Honesty</h3>
        <ul>
          <li>Client and network environments are hostile by default.</li>
          <li>Governance allowlists are policy signals, not cryptographic enforcement.</li>
          <li>
            "Approved list" claims MUST NOT be treated as technical guarantees without
            cryptographic verification of corresponding evidence.
          </li>
        </ul>
      </section>
    </section>

    <section id="verifier-algorithm">
      <h2>Mechanical Verifier Algorithm</h2>
      <ol>
        <li>
          Resolve service and scheme metadata using
          <a href="#op-getTypeDescriptor"><code>getTypeDescriptor</code></a> and
          <a href="#op-getSchemeDescriptor"><code>getSchemeDescriptor</code></a>.
        </li>
        <li>
          Fetch a cheap head view using
          <a href="#op-getEventLogView"><code>getEventLogView</code></a>
          with conditional headers.
        </li>
        <li>
          If head commitments from peer hosts are equal, skip heavy merge processing.
        </li>
        <li>
          If head commitments differ, fetch only the missing event chain segments and validate
          canonicalization, digest links, and proof material for each reported head.
        </li>
        <li>
          Accept merge only when represented as an explicit event that links parent heads.
        </li>
        <li>
          Produce separate outputs: (a) <a>mechanical validity</a>, (b)
          <a>recognition status</a> from external governance inputs.
        </li>
      </ol>
      <p>
        Trust decisions MUST consume both outputs. A positive mechanical result without an
        accepted governance source yields cryptographic validity only.
      </p>
      <p>
        Deterministic processing requirements: verifiers MUST apply the canonicalization and hash
        algorithm declared by
        <a href="#schema-SchemeDescriptor"><code>SchemeDescriptor</code></a>; MUST recompute and
        compare <code>eventDigest</code> and parent commitment tuples for each processed event;
        MUST verify every event proof against its declared cryptosuite profile; and MUST emit a
        deterministic failure code from <a href="#schema-ErrorCode"><code>ErrorCode</code></a>
        whenever any required check fails.
      </p>
    </section>

    <section id="proof-profile-baseline">
      <h2>Proof Profile Baseline</h2>
      <p>
        Unless a profile explicitly overrides this behavior, proof objects for event integrity
        MUST follow the VC Data Integrity proof model
        <a href="#ref-vc-data-integrity">[VC-DATA-INTEGRITY]</a> and MUST include
        <code>type</code>, <code>cryptosuite</code>, and <code>proofValue</code>. ECDSA profiles
        MUST align identifiers and verification rules with
        <a href="#ref-vc-di-ecdsa">[VC-DI-ECDSA]</a>.
      </p>
      <p>
        Verification method resolution SHOULD align with Controlled Identifiers
        <a href="#ref-controller-document">[CONTROLLER-DOCUMENT]</a>.
      </p>
      <p>
        Proof verification MUST be deterministic: canonicalization input, hash input, signature
        input, and verification method resolution MUST produce identical acceptance outcomes for
        identical artifacts.
      </p>
    </section>

    <section id="failure-semantics">
      <h2>Verification Failure Semantics</h2>
      <p>
        Verification failures MUST be reported using deterministic error codes represented by
        <a href="#schema-ErrorCode"><code>ErrorCode</code></a> and conveyed through
        <code>ProblemDetails.code</code>.
      </p>
      <table class="simple tight">
        <thead>
          <tr>
            <th>Error Code</th>
            <th>Failure Condition</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>ERR_SCHEMA_VALIDATION</code></td>
            <td>Input object fails schema or required-field constraints.</td>
          </tr>
          <tr>
            <td><code>ERR_CANONICALIZATION_FAILURE</code></td>
            <td>Canonicalization cannot be completed deterministically.</td>
          </tr>
          <tr>
            <td><code>ERR_DIGEST_MISMATCH</code></td>
            <td>Digest tuple or hash-chain commitment does not match recomputed value.</td>
          </tr>
          <tr>
            <td><code>ERR_UNSUPPORTED_CRYPTOSUITE</code></td>
            <td>Proof declares a cryptosuite not supported by the verifier profile.</td>
          </tr>
          <tr>
            <td><code>ERR_PROOF_VERIFICATION_FAILED</code></td>
            <td>Cryptographic proof verification returns invalid.</td>
          </tr>
          <tr>
            <td><code>ERR_HISTORY_DIVERGENCE_UNRESOLVED</code></td>
            <td>Multiple heads persist without a valid merge event under profile rules.</td>
          </tr>
          <tr>
            <td><code>ERR_POLICY_INPUT_UNAVAILABLE</code></td>
            <td>Required external governance input cannot be resolved.</td>
          </tr>
          <tr>
            <td><code>ERR_POLICY_REJECTED</code></td>
            <td>Policy-layer checks reject an otherwise mechanically valid artifact.</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section id="design-proposal">
      <h2>Architecture Rationale (Non-Normative)</h2>
      <p>
        <span class="status-tag">Architecture Layer</span>
      </p>
      <p>
        GQTS is the reusable event-log substrate for framework components that already depend on
        decentralized verifier retrieval under the `/.well-known/gidas/...` namespace, including
        GDIS and GQSCD artifacts.
      </p>

      <section id="design-log-primitives">
        <h3>Event-Log Properties</h3>
        <p>
          Referenced mechanisms such as CEL and did:webvh converge on the same core
          properties: canonical bytes before hashing/signing, hash-linked history, explicit proof
          material, and retrieval-portable verification.
          <a href="#ref-cel">[CEL]</a>
          <a href="#ref-didwebvh">[DID-WEBVH]</a>
        </p>
        <p>
          GQTS keeps these properties as mandatory invariants while allowing application profiles
          (for example GDIS bindings, trust registries, or device evidence publication) to define
          their own event payload semantics.
        </p>
      </section>

      <section id="design-rfc8615-registration">
        <h3>Well-Known Registration Work Item</h3>
        <p>
          Deployment profiles using hardcoded `/.well-known/` suffixes SHOULD define and publish a
          registry strategy aligned with RFC 8615 and IANA procedures
          <a href="#ref-rfc8615">[RFC8615]</a>
          <a href="#ref-iana-wku">[IANA-WKU]</a>.
        </p>
      </section>

    </section>

    <section id="conformance-classes">
      <h2>Conformance Classes</h2>
      <section id="cc-host">
        <h3>Host Class</h3>
        <p>
          A Host implementation conforms if it serves required OpenAPI operations for at least one
          service type, enforces append-only history storage semantics, supports conditional
          retrieval, and emits deterministic event representations.
        </p>
      </section>

      <section id="cc-verifier">
        <h3>Verifier Class</h3>
        <p>
          A Verifier implementation conforms if it executes
          <a href="#verifier-algorithm">Mechanical Verifier Algorithm</a>, validates cryptographic
          proofs and history-link invariants, and outputs separate mechanical and governance-aware
          result layers.
        </p>
      </section>

      <section id="cc-scheme-publisher">
        <h3>Scheme Publisher Class</h3>
        <p>
          A Scheme Publisher implementation conforms if it publishes normalized governance-scoped
          scheme descriptors and keeps profile declarations consistent with the OpenAPI schema
          contracts.
        </p>
      </section>

      <section id="conformance-reporting">
        <h3>Conformance Reporting Requirements</h3>
        <p>
          A conformance claim MUST be accompanied by a machine-readable conformance report with at
          least the following fields:
        </p>
        <ul>
          <li>implementation identifier and version;</li>
          <li>declared conformance class set;</li>
          <li>requirement coverage list (`REQ-GQTS-xx` identifiers);</li>
          <li>test assertion identifiers and execution results;</li>
          <li>cryptosuite support declaration and verification profile;</li>
          <li>failure-code coverage for negative tests using `ErrorCode` values;</li>
          <li>policy input sources used during recognition-status evaluation.</li>
        </ul>
      </section>
    </section>

    <section id="security-considerations">
      <h2>Security Considerations</h2>
      <ul>
        <li>
          Accepting event material without full canonicalization and proof verification breaks
          tamper-evidence guarantees.
        </li>
        <li>
          Fetching from multiple hosts improves availability but requires strict digest/proof
          checks on all fetched variants.
        </li>
        <li>
          Compromise handling MUST be explicit in history and policy processing, not hidden in
          mutable metadata edits.
        </li>
      </ul>
    </section>

    <section id="privacy-considerations">
      <h2>Privacy Considerations</h2>
      <ul>
        <li>Event payloads SHOULD minimize personal data and prefer digest references.</li>
        <li>
          Globally stable identifiers can be highly linkable; profiles SHOULD define scoped or
          blinded derivations when compatibility permits.
        </li>
        <li>
          Public host operation SHOULD include anti-enumeration controls and auditable access
          policy where required.
        </li>
      </ul>
    </section>

    <section id="open-issues" class="informative">
      <h2>Pending Specification Work</h2>
      <p class="issue">
        Decide final IANA well-known suffix strategy (`gidas` umbrella path versus `gqts`
        direct suffix) before broad hardcoded deployment.
      </p>
      <p class="issue">
        Define v1 event chunking profile details and proof requirements for very large histories.
      </p>
      <p class="issue">
        Define anti-spam/admission strategy for open gossip without introducing closed host
        governance by default.
      </p>
      <p class="issue">
        Define deterministic event-history compaction and long-range proof availability
        requirements.
      </p>
    </section>

    <section class="appendix informative" id="references">
      <h2>References</h2>

      <section>
        <h3>Core Protocol and Registry References</h3>
        <ul>
          <li id="ref-rfc2119">
            <a href="https://www.rfc-editor.org/rfc/rfc2119"
              >[RFC2119] Key words for use in RFCs to Indicate Requirement Levels</a
            >
          </li>
          <li id="ref-rfc8174">
            <a href="https://www.rfc-editor.org/rfc/rfc8174"
              >[RFC8174] Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a
            >
          </li>
          <li id="ref-rfc6838">
            <a href="https://www.rfc-editor.org/rfc/rfc6838"
              >[RFC6838] Media Type Specifications and Registration Procedures</a
            >
          </li>
          <li id="ref-rfc8615">
            <a href="https://www.rfc-editor.org/rfc/rfc8615"
              >[RFC8615] Well-Known Uniform Resource Identifiers (URIs)</a
            >
          </li>
          <li id="ref-rfc9110">
            <a href="https://www.rfc-editor.org/rfc/rfc9110">[RFC9110] HTTP Semantics</a>
          </li>
          <li id="ref-rfc8785">
            <a href="https://www.rfc-editor.org/rfc/rfc8785"
              >[RFC8785] JSON Canonicalization Scheme (JCS)</a
            >
          </li>
          <li id="ref-openapi31">
            <a href="https://spec.openapis.org/oas/v3.1.2.html"
              >[OPENAPI-3.1.2] OpenAPI Specification v3.1.2</a
            >
          </li>
          <li id="ref-iana-wku">
            <a href="https://www.iana.org/assignments/well-known-uris/well-known-uris.xhtml"
              >[IANA-WKU] IANA Well-Known URI Registry</a
            >
          </li>
        </ul>
      </section>

      <section>
        <h3>Proof And Controller References</h3>
        <ul>
          <li id="ref-controller-document">
            <a href="https://www.w3.org/TR/cid-1.0/"
              >[CONTROLLER-DOCUMENT] Controlled Identifiers v1.0</a
            >
          </li>
          <li id="ref-vc-data-integrity">
            <a href="https://www.w3.org/TR/vc-data-integrity/"
              >[VC-DATA-INTEGRITY] Verifiable Credential Data Integrity 1.0</a
            >
          </li>
          <li id="ref-vc-di-ecdsa">
            <a href="https://www.w3.org/TR/vc-di-ecdsa/"
              >[VC-DI-ECDSA] Data Integrity ECDSA Cryptosuites v1.0</a
            >
          </li>
        </ul>
      </section>

      <section>
        <h3>Event-Log References and Inputs</h3>
        <ul>
          <li id="ref-cel">
            <a href="https://w3c-ccg.github.io/cel-spec/"
              >[CEL] Cryptographic Event Log (CEL) Specification</a
            >
          </li>
          <li id="ref-didwebvh">
            <a href="https://identity.foundation/didwebvh/v1.0/"
              >[DID-WEBVH] did:webvh v1.0</a
            >
          </li>
          <li id="ref-gdis-core">
            <a href="https://z-base.github.io/gdis/">[GDIS-CORE] GDIS Core</a>
          </li>
          <li id="ref-gqscd-core">
            <a href="https://z-base.github.io/gqscd/">[GQSCD-CORE] GQSCD Core</a>
          </li>
        </ul>
      </section>

      <section>
        <h3>Law and Policy Inputs</h3>
        <ul>
          <li id="ref-eidas-910">
            <a href="https://eur-lex.europa.eu/eli/reg/2014/910/oj"
              >[EU-910/2014] Regulation (EU) No 910/2014 (eIDAS)</a
            >
          </li>
          <li id="ref-eidas-consolidated">
            <a href="https://eur-lex.europa.eu/legal-content/EN/TXT/?uri=CELEX:02014R0910-20241018"
              >[EU-910-CONS] eIDAS consolidated text</a
            >
          </li>
          <li id="ref-eu-2024-1183">
            <a href="https://eur-lex.europa.eu/eli/reg/2024/1183/oj/eng"
              >[EU-2024/1183] European Digital Identity Framework amendment</a
            >
          </li>
          <li id="ref-eu-trusted-lists">
            <a href="https://digital-strategy.ec.europa.eu/en/policies/eu-trusted-lists"
              >[EU-TRUSTED-LISTS] EU Trusted Lists</a
            >
          </li>
        </ul>
      </section>
    </section>
  </body>
</html>
